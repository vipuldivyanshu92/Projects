<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  
<!-- Mirrored from pylonsbook.com/en/1.0/unicode.html by HTTrack Website Copier/3.x [XR&CO'2008], Thu, 11 Jun 2009 15:42:53 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Chapter 10: Unicode &mdash; Pylons Book v1.0 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Pylons Book v1.0 documentation" href="index.html" />
    <link rel="next" title="Chapter 11: Internationalization and Localization" href="internationalization-and-localization.html" />
    <link rel="prev" title="Chapter 9: URLs, Routing and Dispatch" href="urls-routing-and-dispatch.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="internationalization-and-localization.html" title="Chapter 11: Internationalization and Localization"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="urls-routing-and-dispatch.html" title="Chapter 9: URLs, Routing and Dispatch"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Pylons Book v1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="chapter-10-unicode">
<h1>Chapter 10: Unicode<a class="headerlink" href="#chapter-10-unicode" title="Permalink to this headline">¶</a></h1>
<p id="index-1223">If you’ve ever come across text in a foreign language that contains lots of question mark characters in unexpected positions or if you’ve written Python code that causes an exception such as the following one to be raised, then chances are you have run into a problem with character sets, encodings, and Unicode:</p>
<div class="highlight-python"><pre>UnicodeDecodeError: 'ascii' codec can't decode byte 0xff in position 6: ordinal not in range(128)</pre>
</div>
<p>Many developers try to avoid getting involved with Unicode because these error messages seem obscure and difficult to fix, but the good news is that Python has great Unicode support, so with a little effort, you will be able to banish these problems from your applications entirely as well as properly support languages other than English. This chapter and the next will show you how.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All the libraries that come with Pylons have Unicode support, so it is always best to use Unicode in a Pylons application. The Python 3.0 language will treat all strings as Unicode by default, so Unicode support will become even more standard across all Python libraries in the future.</p>
</div>
<div class="section" id="a-brief-history">
<h2>A Brief History<a class="headerlink" href="#a-brief-history" title="Permalink to this headline">¶</a></h2>
<p id="index-1224">As I’m sure you are aware, computers operate on binary numbers that can be thought of as a collection of 1s and 0s. For example, the binary number 1110 represents the decimal number 14. Each 1 or 0 in the binary number is called a <em>bit</em>. A binary number made up from seven 1s and 0s is called a <em>7-bit</em> number and can represent all the decimal numbers from 0 to 127.</p>
<p id="index-1225">In the early days of computers, people wanted to be able to represent characters as well as binary numbers, and at the time, the most important characters were unaccented English letters, numbers, and punctuation, which could all be represented by a number between 0 and 127. These numbers can therefore all be stored in binary with just seven 1s and 0s (in other words, in 7 bits). The character set defined by these numbers eventually became standardized as ASCII. In the ASCII character set, <em>P</em> is represented by 80, and <em>y</em> is represented by 121. Python understands ASCII, so you can find out the codes for characters with the built-in <tt class="docutils literal"><span class="pre">ord()</span></tt> function like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&quot;P&quot;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&quot;l&quot;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&quot;o&quot;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&quot;n&quot;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&quot;s&quot;</span><span class="p">)</span>
<span class="go">80 121 108 111 110 115</span>
</pre></div>
</div>
<p id="index-1226">You can also find out a character from its ASCII representation with <tt class="docutils literal"><span class="pre">chr()</span></tt> like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">chr</span><span class="p">(</span><span class="mf">80</span><span class="p">),</span> <span class="nb">chr</span><span class="p">(</span><span class="mf">121</span><span class="p">),</span> <span class="nb">chr</span><span class="p">(</span><span class="mf">108</span><span class="p">),</span> <span class="nb">chr</span><span class="p">(</span><span class="mf">111</span><span class="p">),</span> <span class="nb">chr</span><span class="p">(</span><span class="mf">110</span><span class="p">),</span> <span class="nb">chr</span><span class="p">(</span><span class="mf">115</span><span class="p">)])</span>
<span class="go">&#39;Pylons&#39;</span>
</pre></div>
</div>
<p id="index-1227">Computers of the day used 8-bit bytes in their calculations. These can represent the decimal numbers 0 to 255, so people quickly realized that an extra 128 characters were available. Different people assigned these extra numbers to different characters, and before long, these different collections of extra characters were also standardized into sets known as <em>code pages</em>. As an example, code page 857 is for Turkish characters, and code page 861 is for Icelandic characters. The code page system was adequate for representing most Western languages as long as you used the correct code page for the language you wanted to represent and as long as you didn’t want to work on a document that contained two different languages at once.</p>
<p>It quickly became apparent, though, that code pages would not be suitable for representing every language. Asian languages in particular can contain many more than 256 characters, so a system was needed that represented a much wider set of characters. This is where Unicode came in.</p>
<p id="index-1228">The origins of Unicode date back to 1987 when Joe Becker, Lee Collins, and Mark Davis started investigating the practicalities of creating a universal character set. In the following year, Joe Becker published a draft proposal for an “international/multilingual text character encoding system, tentatively called Unicode.” In this document, entitled “Unicode 88,” he outlined a model where every script and character in modern usage could be represented in 16 bits. It soon became clear that people would also want to be able to represent scripts and characters that weren’t in modern-day use, and over successive releases of the Unicode standard more scripts and characters were added until the most recent version, Unicode 5.1, was released in April 2008 with more than 100,000 characters. As you can imagine, this requires more than the 16 bits of Joe Becker’s original draft of Unicode 88.</p>
</div>
<div class="section" id="introducing-unicode">
<h2>Introducing Unicode<a class="headerlink" href="#introducing-unicode" title="Permalink to this headline">¶</a></h2>
<p id="index-1229">Unicode is an industry standard allowing computers to consistently represent and manipulate text expressed in most of the world’s writing systems. Unlike ASCII, where each character is represented in 7 bits, Unicode characters are represented by something called a <em>code point</em>, which is effectively an abstract integer ID for that character. For example, the characters in <em>Pylons</em> could be represented by the Unicode code points <tt class="docutils literal"><span class="pre">U+0050</span></tt>, <tt class="docutils literal"><span class="pre">U+0079</span></tt>, <tt class="docutils literal"><span class="pre">U+006C</span></tt>, <tt class="docutils literal"><span class="pre">U+006F</span></tt>, <tt class="docutils literal"><span class="pre">U+006E</span></tt>, and <tt class="docutils literal"><span class="pre">U+0073</span></tt>.</p>
<p id="index-1230">If you’ve worked with hexadecimal numbers, you might notice that the last two characters of each code point correspond to the decimal representation of the corresponding character in the ASCII character set for the word <em>Pylons</em> shown in the previous paragraph. This is because the first 256 Unicode code points were made identical to the numbers representing the characters in the ISO 8859-1 encoding of the Latin alphabet (less formally known as Latin-1). This in turn shares the first 128 characters and their respective codes with the ASCII character set. I’ll return to the significance of this backward compatibility in a moment.</p>
<p id="index-1231">Unicode also has the concept of an <em>encoding</em>. One way of encoding Unicode code points into binary numbers on a disk would be to store each code point as a 32-bit (4-byte) number (since a 32-bit number is more than capable of storing every possible Unicode code point). This might seem sensible at first, but representing Unicode code points on disk in this way would take up a lot of space, especially if you used only those characters with low code points such as those also represented in ISO 8859-1 and ASCII because each character would be using 4 bytes when it really needed only one.</p>
<p id="index-1232">Another way of storing the values would be to use a variable number of bytes for each character. Those with low code points such as the unaccented English characters could be stored in 1 byte, and those with much higher code points such as Arabic or Chinese characters would use more than 1 byte. This would mean that all the Unicode characters could be represented if necessary, but the most commonly used ones (the unaccented English characters) could be represented in just 1 byte. This is exactly what happens in the UTF-8 encoding, which you will probably have come across. UTF-8 is one of the most popular encodings for Python programmers, so much so that Python 3.0 will assume that files you open are encoded in UTF-8 unless you say otherwise.</p>
<p id="index-1233">Encoding Unicode characters with a variable number of bytes for each character as UTF-8 has an interesting side effect. It means that UTF-8 encoded Unicode for the characters represented by the ASCII character set has the same binary representation as ASCII itself. This means computers can treat UTF-8 encoded Unicode as ASCII without any errors being raised as long as characters used are in the first 128 Unicode code points. This explains why your application might already be working perfectly well with certain Unicode strings even though you haven’t made a special effort to work with any character set except ASCII. This is also why as soon as a character such as <tt class="docutils literal"><span class="pre">£</span></tt> or <tt class="docutils literal"><span class="pre">é</span></tt> is entered, the application will break because these are not ASCII characters; therefore, treating their UTF-8 encoded versions as ASCII will cause the kind of <tt class="docutils literal"><span class="pre">UnicodeDecodeError</span></tt> shown at the start of the chapter.</p>
<p>Luckily, working properly with Unicode is very straightforward, so you shouldn’t need to rely on the backward compatibility of the UTF-8 encoding for the ASCII characters.</p>
<p id="index-1234">Before you look at Unicode in Python, I’ll recap the important points:</p>
<blockquote>
<ul>
<li><p class="first">Unicode can represent pretty much any character in any writing system in widespread use today as well as some historical characters.</p>
</li>
<li><p class="first">Unicode uses code points to represent characters, and the way these map to bits on disk depends on the encoding.</p>
</li>
<li><p class="first">The most popular encoding is UTF-8, which has several convenient properties:</p>
<ul class="simple">
<li>It can handle any Unicode code point.</li>
<li>A string of ASCII text is also valid UTF-8 encoded Unicode.</li>
</ul>
<ul class="simple" id="index-1235">
<li>UTF-8 doesn’t use much storage space; the majority of code points are turned into 2 bytes, and values less than 128 occupy only 1 byte.</li>
</ul>
</li>
</ul>
</blockquote>
</div>
<div class="section" id="unicode-in-python-2">
<h2>Unicode in Python 2<a class="headerlink" href="#unicode-in-python-2" title="Permalink to this headline">¶</a></h2>
<p id="index-1236">In Python 2, Unicode strings are expressed as instances of the built-in <tt class="docutils literal"><span class="pre">unicode</span></tt> type. Under the hood, Python represents Unicode strings as either 16-bit or 32-bit integers, depending on the way the Python interpreter was compiled. Python 3 will treat all strings as Unicode automatically, but the discussion in this chapter relates only to the Unicode handling of recent Python 2 releases such as Python 2.4, 2.5, and 2.6.</p>
<div class="section" id="unicode-literals">
<h3>Unicode Literals<a class="headerlink" href="#unicode-literals" title="Permalink to this headline">¶</a></h3>
<p id="index-1237">In Python source code, Unicode literals are written as strings prefixed with the <tt class="docutils literal"><span class="pre">u</span></tt> or <tt class="docutils literal"><span class="pre">U</span></tt> character (although you will hardly ever see the uppercase version used).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">u&#39;abcd&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">U&#39;efgh&#39;</span>
</pre></div>
</div>
<p>You can also use <tt class="docutils literal"><span class="pre">&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt>, or <tt class="docutils literal"><span class="pre">'''</span></tt> versions too. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">u&quot;&quot;&quot;This</span>
<span class="gp">... </span><span class="s">is a multiline</span>
<span class="gp">... </span><span class="s">Unicode string&quot;&quot;&quot;</span>
</pre></div>
</div>
<p id="index-1238">Individual code points can be written using the escape sequence <tt class="docutils literal"><span class="pre">\u</span></tt> followed by four hex digits specifying the code point. You can also use <tt class="docutils literal"><span class="pre">\U</span></tt> followed by eight hex digits instead of four. Unicode literals can also use the same escape sequences as 8-bit strings including <tt class="docutils literal"><span class="pre">\x</span></tt>, but this takes only two hex digits, so it can’t express many of the available code points. You can add characters to Unicode strings using the <tt class="docutils literal"><span class="pre">unichr()</span></tt> built-in function, and you can find out what the ordinal is with <tt class="docutils literal"><span class="pre">ord()</span></tt>, which you also saw earlier in the chapter when it was used with ASCII characters.</p>
<p>Here is an example demonstrating the different alternatives:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">u&quot;</span><span class="se">\x66\u0072\u0061\U0000006e</span><span class="s">&quot;</span> <span class="o">+</span> <span class="nb">unichr</span><span class="p">(</span><span class="mf">231</span><span class="p">)</span> <span class="o">+</span> <span class="s">u&quot;ais&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">),</span>
<span class="gp">...</span>
<span class="go">97 102 114 97 110 231 97 105 115</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">\x66</span></tt> is a two-digit hex escape, <tt class="docutils literal"><span class="pre">\u0072</span></tt> and <tt class="docutils literal"><span class="pre">\u0061</span></tt> are four-digit Unicode escapes, and <tt class="docutils literal"><span class="pre">\u0000006e</span></tt> is an eight-digit Unicode escape. The example also demonstrates the use of <tt class="docutils literal"><span class="pre">unichr()</span></tt>. The word made in this is as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">s</span>
<span class="go">français</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last" id="index-1239">If you are working with Unicode in detail, you might be interested in the <tt class="docutils literal"><span class="pre">unicodedata</span></tt> module, which can be used to find out Unicode properties such as a character’s name, category, numeric value, and the like.</p>
</div>
</div>
<div class="section" id="handling-errors">
<h3>Handling Errors<a class="headerlink" href="#handling-errors" title="Permalink to this headline">¶</a></h3>
<p id="index-1240">Now that you have seen how to write Unicode literals, let’s look at how you can create Unicode strings with the <tt class="docutils literal"><span class="pre">unicode()</span></tt> constructor. Here is an example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cost</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="s">&#39;50.00&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cost</span>
<span class="go">u&#39;50.00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
<span class="go">&lt;type &#39;unicode&#39;&gt;</span>
</pre></div>
</div>
<p>Let’s see what happens if you try to concatenate the <tt class="docutils literal"><span class="pre">cost</span></tt> Unicode string with a normal ASCII string:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;$&#39;</span> <span class="o">+</span> <span class="n">cost</span>
<span class="go">u&#39;$50.00&#39;</span>
</pre></div>
</div>
<p>Python decodes the string <tt class="docutils literal"><span class="pre">'$'</span></tt> from ASCII to Unicode, concatenates the two Unicode strings, and returns the result.</p>
<p>Now let’s try to use a <tt class="docutils literal"><span class="pre">£</span></tt> sign instead of a <tt class="docutils literal"><span class="pre">$</span></tt>. The <tt class="docutils literal"><span class="pre">£</span></tt> character is not an ASCII character, so you have to represent it by its ordinal, which is 163. Let’s see what happens:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">chr</span><span class="p">(</span><span class="mf">163</span><span class="p">)</span> <span class="o">+</span> <span class="s">u&#39;50.00&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">&lt;module&gt;</span>
<span class="nc">UnicodeDecodeError: &#39;ascii&#39; codec can&#39;t decode byte 0xa3 in position 0</span>: <span class="n-Identifier">ordinal not in range(128)</span>
</pre></div>
</div>
<p>In this case, because <tt class="docutils literal"><span class="pre">£</span></tt> is not an ASCII character, when Python internally calls <tt class="docutils literal"><span class="pre">unicode(chr(163))</span></tt> to try to decode it from ASCII to Unicode, an error occurs.</p>
<p id="index-1241">Python’s <tt class="docutils literal"><span class="pre">unicode()</span></tt> constructor takes three arguments, including an <tt class="docutils literal"><span class="pre">errors</span></tt> argument that determines what should happen in a situation like this:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">string</span></tt></dt>
<dd>This is the Python string to decode to Unicode.</dd>
<dt><tt class="docutils literal"><span class="pre">encoding</span></tt></dt>
<dd>This is an optional encoding to specify how the string is currently encoded. If you don’t specify an encoding, ASCII will be used, so characters with code points greater than 127 will be treated as errors.</dd>
<dt><tt class="docutils literal"><span class="pre">errors</span></tt></dt>
<dd>This specifies how to handle any errors. This can be one of the following: the string <tt class="docutils literal"><span class="pre">&quot;strict&quot;</span></tt> (the default), which results in a <tt class="docutils literal"><span class="pre">ValueError</span></tt> being raised if an invalid character is found; <tt class="docutils literal"><span class="pre">&quot;ignore&quot;</span></tt>, which simply results in any errors being silently ignored; or <tt class="docutils literal"><span class="pre">&quot;replace&quot;</span></tt>, which causes the official Unicode replacement character, <tt class="docutils literal"><span class="pre">U+FFFD</span></tt> (usually displayed ￝), to be inserted instead.</dd>
</dl>
<p>Let’s explore what happens if you perform the conversion explicitly and use the <tt class="docutils literal"><span class="pre">errors</span></tt> option:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">unicode</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="mf">163</span><span class="p">),</span> <span class="n">errors</span><span class="o">=</span><span class="s">&#39;ignore&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s">u&#39;50.00&#39;</span>
<span class="go">u&#39;50.00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">unicode</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="mf">163</span><span class="p">),</span> <span class="n">errors</span><span class="o">=</span><span class="s">&#39;replace&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s">u&#39;50.00&#39;</span>
<span class="go">u&#39;\ufffd50.00&#39;</span>
</pre></div>
</div>
<p id="index-1242">As you can see, using <tt class="docutils literal"><span class="pre">'ignore'</span></tt> silently ignores the problem, and using <tt class="docutils literal"><span class="pre">'replace'</span></tt> results in the Unicode character <tt class="docutils literal"><span class="pre">U+FFFD</span></tt> being inserted in place of the pound sign. Neither of these is quite what you want. The solution to the problem lies in understanding the <tt class="docutils literal"><span class="pre">encoding</span></tt> option. Let’s look at encoding and decoding Unicode data next.</p>
</div>
<div class="section" id="decoding-unicode">
<h3>Decoding Unicode<a class="headerlink" href="#decoding-unicode" title="Permalink to this headline">¶</a></h3>
<p id="index-1243">Unicode strings are simply a series of Unicode code points. When you are converting an ASCII or UTF-8 string to Unicode, you are actually <em>decoding</em> it; when you are converting from Unicode to UTF-8 or ASCII, you are <em>encoding</em> it. This is why the error in the example said that the ASCII codec could not <em>decode</em> the byte <tt class="docutils literal"><span class="pre">0xa3</span></tt> from ASCII to Unicode. You might be used to thinking of ASCII as the “natural” representation of characters and anything else to be an encoding, but this is not the way you should think with Unicode. You should always think of the Unicode code point as the “natural” representation and anything else as being a particular encoding.</p>
<p>The <tt class="docutils literal"><span class="pre">0xa3</span></tt> characters that appeared in the <tt class="docutils literal"><span class="pre">UnicodeDecodeError</span></tt> message are hex for 163, which represents the <tt class="docutils literal"><span class="pre">£</span></tt> sign. The error occurred because this is outside the ASCII range. However, this character is present in the ISO 8859-1 character set. If you tell Python that the data it is decoding is encoded with the <tt class="docutils literal"><span class="pre">'iso_8859_1'</span></tt> character set, you get the result you expected:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">unicode</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="mf">163</span><span class="p">),</span> <span class="n">encoding</span><span class="o">=</span><span class="s">&#39;iso_8859_1&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">cost</span>
<span class="go">u&#39;\xa350.00&#39;</span>
</pre></div>
</div>
<p>Notice that because 163 can be represented in just two hex digits, Python chose to use the <tt class="docutils literal"><span class="pre">\x</span></tt> representation rather than its <tt class="docutils literal"><span class="pre">\u</span></tt> or <tt class="docutils literal"><span class="pre">\U</span></tt> representation of Unicode characters.</p>
<p>Let’s print the result:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">u&#39;</span><span class="se">\xa3</span><span class="s">50.00&#39;</span>
<span class="go">£50.00</span>
</pre></div>
</div>
<p id="index-1244">Be aware that not all terminals will be able to display all Unicode characters when printed like this; it will depend on the encoding of the terminal and the fonts available on the system.</p>
</div>
<div class="section" id="encoding-unicode">
<h3>Encoding Unicode<a class="headerlink" href="#encoding-unicode" title="Permalink to this headline">¶</a></h3>
<p id="index-1245">Now that you’ve seen how to decode to Unicode, let’s see how to encode it. All Python Unicode objects have an <tt class="docutils literal"><span class="pre">encode()</span></tt> method that takes the encoding you want to use as its argument. It is used like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">u&#39;$50.00&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="go">&#39;$50.00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">u&#39;$50.00&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;ascii&#39;</span><span class="p">)</span>
<span class="go">&#39;$50.00&#39;</span>
</pre></div>
</div>
<p>As you can see, <tt class="docutils literal"><span class="pre">u'$50.00'</span></tt>, when encoded to UTF-8, is the same as the ASCII representation. The same cannot be said for <tt class="docutils literal"><span class="pre">u'£50.00'</span></tt> because this isn’t an ASCII character, as I’ve already explained:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">u&#39;</span><span class="se">\xa3</span><span class="s">50.00&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="go">&#39;\xc2\xa350.00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&#39;</span><span class="se">\xc2\xa3</span><span class="s">50.00&#39;</span>
<span class="go">£50.00</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">u&#39;</span><span class="se">\xa3</span><span class="s">50.00&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;ascii&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">&lt;module&gt;</span>
<span class="nc">UnicodeEncodeError: &#39;ascii&#39; codec can&#39;t encode character u&#39;\xa3&#39; in position 0</span>: <span class="n-Identifier">ordinal not in range(128)</span>
</pre></div>
</div>
<p id="index-1246">Once again, you get the familiar <tt class="docutils literal"><span class="pre">UnicodeEncodeError</span></tt>, this time specifying that the encoding failed as you would expect.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Python supports many more character encodings besides the ones mentioned in this chapter; you can find the full list at <a class="reference external" href="http://docs.python.org/lib/standard-encodings.html">http://docs.python.org/lib/standard-encodings.html</a>.</p>
</div>
</div>
<div class="section" id="python-source-code-encoding">
<h3>Python Source Code Encoding<a class="headerlink" href="#python-source-code-encoding" title="Permalink to this headline">¶</a></h3>
<p id="index-1247">If you are working with non-ASCII characters in your application, you are likely to also want to be able to use them in your Python source code. Although you could manually escape each character you use in a Unicode literal, Python 2.4 and newer let you define the encoding you are using at the top of the source file like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># -*- coding: utf-8 -*-</span>
</pre></div>
</div>
<p>This special setting tells Python to treat the source code as UTF-8 encoded Unicode. This allows you to use Unicode characters in the source code itself as long as you remember to set your editor to save the file in UTF-8. Windows users who use the SciTE editor can specify the encoding of their file from the menu using the File -&gt; Encoding menu option. Vim users can set the encoding with <tt class="docutils literal"><span class="pre">set</span> <span class="pre">encoding=utf8</span></tt>.</p>
<p>If you use a non-ASCII character, which is still part of the ISO 8859-1 character set, in your source file (such as the <tt class="docutils literal"><span class="pre">£</span></tt> character) but fail to specify an encoding, versions of Python newer than 2.4 will assume that you are using the ISO 8859-1 character set but will still issue a warning:</p>
<div class="highlight-python"><pre>sys:1: DeprecationWarning: Non-ASCII character '\xe9' in file testas.py on line
2, but no encoding declared; see http://www.python.org/peps/pep-0263.html for de
tails</pre>
</div>
<p>You can correct this by specifying the correct encoding at the top of your source file. If you use other characters but fail to specify an encoding or if you forget to save the file in the encoding you have specified, Python will give an error.</p>
<p>If you look back at Chapter 8, you’ll see that the base template you created for the SimpleSite tutorial starts with this line:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">## -- coding: utf-8 --</span>
</pre></div>
</div>
<p id="index-1248">When Mako creates a Python version of the template in the Mako cache, the <tt class="docutils literal"><span class="pre">##</span></tt> characters get converted to a single <tt class="docutils literal"><span class="pre">#</span></tt> character. This results in the Python file having the correct encoding definition at the top, which allows you to use Unicode characters within the template source file as long as your editor encodes the file to UTF-8 when you saves it.</p>
</div>
<div class="section" id="unicode-and-files">
<h3>Unicode and Files<a class="headerlink" href="#unicode-and-files" title="Permalink to this headline">¶</a></h3>
<p id="index-1249">To write Unicode data to a file, you will need to encode it first. Likewise, when reading encoded Unicode from a file, it will need to be decoded. The easiest way to handle this in Python is to use the <tt class="docutils literal"><span class="pre">codecs</span></tt> module. Here is an example of how to read Unicode from a UTF-8 encoded file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">codecs</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#39;unicode.txt&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">&#39;utf-8&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">print</span> <span class="nb">repr</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
<p>Each line will have been automatically decoded to a Unicode string. Here’s an example of writing Unicode to a file encoded in ISO 8859-1:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#39;unicode.txt&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">&#39;latin-1&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">u&quot;</span><span class="se">\x66\u0072\u0061\U0000006e</span><span class="s">&quot;</span> <span class="o">+</span> <span class="nb">unichr</span><span class="p">(</span><span class="mf">231</span><span class="p">)</span> <span class="o">+</span> <span class="s">u&quot;ais&quot;</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>I’ve used <tt class="docutils literal"><span class="pre">latin-1</span></tt> here to demonstrate that Python will accept a number of different descriptions if an encoding has multiple names in common use. Reading/writing files in different encodings is almost as easy as normal Python file operations.</p>
<p>It is also possible to use Unicode strings as file names if the underlying filesystem supports Unicode file names. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">filename</span> <span class="o">=</span> <span class="s">u&quot;</span><span class="se">\x66\u0072\u0061\U0000006e</span><span class="s">&quot;</span> <span class="o">+</span> <span class="nb">unichr</span><span class="p">(</span><span class="mf">231</span><span class="p">)</span> <span class="o">+</span> <span class="s">u&quot;ais&quot;</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;Bonjour!</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p id="index-1250">Other functions such as <tt class="docutils literal"><span class="pre">os.listdir()</span></tt> will return Unicode if you pass them a Unicode argument and will try to return strings if you pass an ordinary 8-bit string. Add the previous code to a file called <tt class="docutils literal"><span class="pre">test.py</span></tt>, and then add the following afterward:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">os</span>
<span class="k">print</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s">u&#39;.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If you ran <tt class="docutils literal"><span class="pre">python</span> <span class="pre">test.py</span></tt>, you would see the following output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="s">&#39;Fran</span><span class="se">\xcc\xa7</span><span class="s">ais&#39;</span><span class="p">,</span> <span class="s">&#39;test.py&#39;</span><span class="p">]</span>
<span class="p">[</span><span class="s">u&#39;Fran</span><span class="se">\u0327</span><span class="s">ais&#39;</span><span class="p">,</span> <span class="s">u&#39;test.py&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p id="index-1251">As you can see from the second line, when <tt class="docutils literal"><span class="pre">os.listdir()</span></tt> is given a Unicode argument, it returns Unicode strings.</p>
</div>
</div>
<div class="section" id="unicode-considerations-in-pylons-programming">
<h2>Unicode Considerations in Pylons Programming<a class="headerlink" href="#unicode-considerations-in-pylons-programming" title="Permalink to this headline">¶</a></h2>
<p id="index-1252">There are three main rules when dealing with using Unicode in a Pylons application:</p>
<p><em>The main rule is that your application should use Unicode for all strings internally, decoding any input to Unicode as soon as it enters the application and encoding the Unicode to UTF-8 or another encoding only on output.</em> If you perform all the decoding right at the edge of your application, as soon as it is passed any encoded Unicode data, then it will be obvious where any problems are caused. If you fail to do this and some of the data your application receives is badly encoded, it is possible your application will crash in an obscure place or, worse, that the badly encoded data poses a security risk.</p>
<p><em>The second rule is to always test your application with characters greater than 127 wherever possible.</em> If you fail to do this, you might think your application is working fine, but as soon as your users do put in non-ASCII characters, you will have problems. Using Arabic is always a good test, and <a class="reference external" href="http://www.google.ae/">http://www.google.ae</a> is a good source of sample text.</p>
<p><em>The third rule is to always do any checking of a string for illegal characters once it’s in the form that will be used or stored; otherwise, the illegal characters might be disguised.</em></p>
<p>For example, let’s say you have a content management system that takes a Unicode file name and you want to disallow paths with a <tt class="docutils literal"><span class="pre">/</span></tt> character. You might write this code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># DO NOT DO THIS</span>
<span class="k">def</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">if</span> <span class="s">&#39;/&#39;</span> <span class="ow">in</span> <span class="n">filename</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;&#39;/&#39; not allowed in filenames&quot;</span><span class="p">)</span>
    <span class="n">unicode_name</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&#39;base64&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">unicode_name</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
    <span class="c"># ... return contents of file ...</span>
</pre></div>
</div>
<p>This is incorrect because the check was performed before the actual data to be used was decoded. An attacker could have passed the data <tt class="docutils literal"><span class="pre">L2V0Yy9wYXNzd2Q=</span></tt>, which is the base-64 encoded form of the string <tt class="docutils literal"><span class="pre">'/etc/passwd'</span></tt>. The previous code would have resulted in this file being opened and returned to the browser, which wasn’t what you expected. Instead, decode the data first and then perform the check. Although this is obvious advice when using the base-64 encoding where the encoded version looks very different from the original, it is less obvious when using UTF-8 where you could easily forget you are not using a decoded string.</p>
<p id="index-1253">Those are the three basic rules, so now I will cover some of the places you might want to perform Unicode decoding in a Pylons application.</p>
<div class="section" id="request-parameters">
<h3>Request Parameters<a class="headerlink" href="#request-parameters" title="Permalink to this headline">¶</a></h3>
<p id="index-1254">Pylons automatically decodes incoming form parameters into Unicode objects so that when you access <tt class="docutils literal"><span class="pre">request.POST</span></tt>, <tt class="docutils literal"><span class="pre">request.GET</span></tt>, or <tt class="docutils literal"><span class="pre">request.params</span></tt> in your application, the values are already Unicode strings. Only parameter values (not their associated names) are decoded to Unicode by default. Since parameter names commonly map directly to Python variable names (which are restricted to the ASCII character set), it’s usually preferable to handle them as strings.</p>
<p>You can change the encoding used to decode the request information by setting the <tt class="docutils literal"><span class="pre">request.charset</span></tt> attribute.</p>
</div>
<div class="section" id="templating">
<h3>Templating<a class="headerlink" href="#templating" title="Permalink to this headline">¶</a></h3>
<p id="index-1255">Pylons uses Mako as its default templating language. Mako handles all content as Unicode internally. It only deals in raw strings upon the final rendering of the template just before it returns a value from the <tt class="docutils literal"><span class="pre">render()</span></tt> function. The encoding of the rendered string can be configured; Pylons sets the default value to UTF-8. To change this value, edit your project’s <tt class="docutils literal"><span class="pre">config/environment.py</span></tt> file, and update the <tt class="docutils literal"><span class="pre">output_encoding</span></tt> argument to <tt class="docutils literal"><span class="pre">TemplateLookup</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Create the Mako TemplateLookup, with the default auto-escaping</span>
<span class="n">config</span><span class="p">[</span><span class="s">&#39;pylons.app_globals&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mako_lookup</span> <span class="o">=</span> <span class="n">TemplateLookup</span><span class="p">(</span>
    <span class="n">directories</span><span class="o">=</span><span class="n">paths</span><span class="p">[</span><span class="s">&#39;templates&#39;</span><span class="p">],</span>
    <span class="n">module_directory</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">app_conf</span><span class="p">[</span><span class="s">&#39;cache_dir&#39;</span><span class="p">],</span> <span class="s">&#39;templates&#39;</span><span class="p">),</span>
    <span class="n">input_encoding</span><span class="o">=</span><span class="s">&#39;utf-8&#39;</span><span class="p">,</span>     <span class="n">output_encoding</span><span class="o">=</span><span class="s">&#39;utf-8&#39;</span><span class="p">,</span>
    <span class="n">imports</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;from webhelpers.html import escape&#39;</span><span class="p">],</span>
    <span class="n">default_filters</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;escape&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p id="index-1256">The <tt class="docutils literal"><span class="pre">input_encoding</span></tt> argument specifies the encoding that Mako expects the templates to have if they don’t have an explicit <tt class="docutils literal"><span class="pre">##</span> <span class="pre">-*-</span> <span class="pre">coding:</span> <span class="pre">utf-8</span> <span class="pre">-*-</span></tt> comment at the top of the file. You can find more information about Unicode in Mako at <a class="reference external" href="http://www.makotemplates.org/docs/unicode.html">http://www.makotemplates.org/docs/unicode.html</a>.</p>
</div>
<div class="section" id="output-encoding">
<h3>Output Encoding<a class="headerlink" href="#output-encoding" title="Permalink to this headline">¶</a></h3>
<p id="index-1257">Web pages should always be generated with a specific encoding, most likely UTF-8. At the very least, that means you should specify the following in the <tt class="docutils literal"><span class="pre">&lt;head&gt;</span></tt> section of your HTML:</p>
<div class="highlight-python"><pre>&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;</pre>
</div>
<p>You can specify the character set for the HTTP response from within a controller action using the Pylons <tt class="docutils literal"><span class="pre">response</span></tt> global:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">response</span><span class="o">.</span><span class="n">charset</span> <span class="o">=</span> <span class="s">&#39;utf8&#39;</span>
</pre></div>
</div>
<p>This will automatically add the character set to the end of the <tt class="docutils literal"><span class="pre">Content-type</span></tt> header, and most browsers will trust this over the value in the <tt class="docutils literal"><span class="pre">&lt;meta&gt;</span></tt> tag. When you return a Unicode string from the controller action, it will be encoded using the character specified by <tt class="docutils literal"><span class="pre">response.charset</span></tt>, but if you return a non-Unicode string, it will be passed directly to the browser without being encoded again because it is assumed you have already encoded it.</p>
<p id="index-1258">The web browser will usually submit form data back to the server using the same character set as that used in the page containing the form. You should therefore try to make sure you are using the same character set in <tt class="docutils literal"><span class="pre">request.charset</span></tt> and <tt class="docutils literal"><span class="pre">response.charset</span></tt>. The defaults of UTF-8 are a good choice, though.</p>
</div>
<div class="section" id="databases">
<h3>Databases<a class="headerlink" href="#databases" title="Permalink to this headline">¶</a></h3>
<p id="index-1259">Another place where you will have to think about encoding and decoding is the database. You should encode to whichever encoding the database expects immediately before executing a query and decode to Unicode immediately after receiving results from the database.</p>
<p id="index-1260">SQLAlchemy has a <tt class="docutils literal"><span class="pre">Unicode</span></tt> column type that you can use to store Unicode characters. If you use this column type, SQLAlchemy will be responsible for handling the encoding and decoding for you so that you don’t need to worry about it yourself. If you look back at the model for the SimpleSite application, you’ll see that you have already been using <tt class="docutils literal"><span class="pre">Unicode</span></tt> columns. This is good practice because you never know when a user of your application might place a non-ASCII character in a form field, and it is best to be able to handle that situation.</p>
</div>
<div class="section" id="a-complete-request-cycle">
<h3>A Complete Request Cycle<a class="headerlink" href="#a-complete-request-cycle" title="Permalink to this headline">¶</a></h3>
<p id="index-1261">Now that you’ve seen the various places your Pylons applications might have to deal with Unicode, I’ll take you through an example request cycle and explain exactly what happens in terms of encoding and decoding Unicode.</p>
<p>Start the SimpleSite application, and edit a page by visiting <a class="reference external" href="http://localhost:5000/page/view/1">http://localhost:5000/page/view/1</a>. Try copying and pasting some Chinese or Arabic text into the content field. (Just search Google for the words <em>Arabic</em> or <em>Chinese characters</em>, and some of the results are bound to contain suitable sample text.) When you save the page, the text will be sent to your application as UTF-8 (since this is the encoding of the page). Pylons will then receive the request, and the form fields will be decoded to Unicode in the Pylons <tt class="docutils literal"><span class="pre">request</span></tt> global. The code within the <tt class="docutils literal"><span class="pre">view()</span></tt> action then retrieves the value of the content field from <tt class="docutils literal"><span class="pre">request.params</span></tt> where it has already been decoded to a Unicode string. It then sets the <tt class="docutils literal"><span class="pre">.content</span></tt> attribute of the <tt class="docutils literal"><span class="pre">page</span></tt> object using the Unicode value. When the session is committed, the page object is automatically flushed. SQLAlchemy takes over and performs the necessary encoding before sending the content to the underlying database engine.</p>
<p>When the saved page is redisplayed, SQLAlchemy will issue a query to fetch the content and decode the results it fetches to Unicode. The page’s content data is passed as a Unicode string to a Mako template where it is rendered. The <tt class="docutils literal"><span class="pre">render()</span></tt> function will obtain the result from Mako and return the entire template as a UTF-8 encoded string, which is then returned from the <tt class="docutils literal"><span class="pre">view()</span></tt> action. Pylons assembles the response using the UTF-8 encoded response from the action and any settings in the <tt class="docutils literal"><span class="pre">response</span></tt> global. Because <tt class="docutils literal"><span class="pre">response.charset</span></tt> is set to <tt class="docutils literal"><span class="pre">'utf-8'</span></tt>, Pylons adds the following header to the response:</p>
<div class="highlight-python"><pre>Content-Type: text/html; charset=utf-8</pre>
</div>
<p id="index-1262">Pylons then returns the response to the browser. The browser knows to expect UTF-8 because of the <tt class="docutils literal"><span class="pre">charset=utf=8</span></tt> part of the previous header and decodes the content that follows to its Unicode representation so that it can correctly display the text.</p>
</div>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>You should now understand the history of Unicode, how to use it in Python, and where to apply Unicode encoding and decoding in a Pylons application. You should also be able to use Unicode in your web app; remember that the main rule is to use UTF-8 to talk to the world, performing the necessary encoding and decoding at the very edge of your application (or letting Pylons do it for you!).</p>
<p id="index-1263">Now that you know how to handle multiple different characters and scripts, it is time to turn your attention to how to write a Pylons application that is designed to be able to be used by people from different countries at the same time, customizing the language used on each request for each user. You’ll learn this in the next chapter.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">Chapter 10: Unicode</a><ul>
<li><a class="reference external" href="#a-brief-history">A Brief History</a></li>
<li><a class="reference external" href="#introducing-unicode">Introducing Unicode</a></li>
<li><a class="reference external" href="#unicode-in-python-2">Unicode in Python 2</a><ul>
<li><a class="reference external" href="#unicode-literals">Unicode Literals</a></li>
<li><a class="reference external" href="#handling-errors">Handling Errors</a></li>
<li><a class="reference external" href="#decoding-unicode">Decoding Unicode</a></li>
<li><a class="reference external" href="#encoding-unicode">Encoding Unicode</a></li>
<li><a class="reference external" href="#python-source-code-encoding">Python Source Code Encoding</a></li>
<li><a class="reference external" href="#unicode-and-files">Unicode and Files</a></li>
</ul>
</li>
<li><a class="reference external" href="#unicode-considerations-in-pylons-programming">Unicode Considerations in Pylons Programming</a><ul>
<li><a class="reference external" href="#request-parameters">Request Parameters</a></li>
<li><a class="reference external" href="#templating">Templating</a></li>
<li><a class="reference external" href="#output-encoding">Output Encoding</a></li>
<li><a class="reference external" href="#databases">Databases</a></li>
<li><a class="reference external" href="#a-complete-request-cycle">A Complete Request Cycle</a></li>
</ul>
</li>
<li><a class="reference external" href="#summary">Summary</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="urls-routing-and-dispatch.html"
                                  title="previous chapter">Chapter 9: URLs, Routing and Dispatch</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="internationalization-and-localization.html"
                                  title="next chapter">Chapter 11: Internationalization and Localization</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/unicode.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="http://pylonsbook.com/en/1.0/search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="internationalization-and-localization.html" title="Chapter 11: Internationalization and Localization"
             >next</a> |</li>
        <li class="right" >
          <a href="urls-routing-and-dispatch.html" title="Chapter 9: URLs, Routing and Dispatch"
             >previous</a> |</li>
        <li><a href="index.html">Pylons Book v1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2009, James Gardner.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.1.
    </div>
  </body>

<!-- Mirrored from pylonsbook.com/en/1.0/unicode.html by HTTrack Website Copier/3.x [XR&CO'2008], Thu, 11 Jun 2009 15:42:53 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>